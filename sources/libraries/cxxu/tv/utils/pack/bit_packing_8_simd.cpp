//
// Automatically generated by gen-bit-packers, do not edit
//
#include <immintrin.h>

#include <cxxu/pack/bit_packing_8.hpp>

namespace cxxu {
namespace pack {

//
// Various SIMD intrinsics helpers to ease writing
//
inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
adapt_mask_8(const uint32_t b)
{ return _mm_set1_epi8((uint8_t) b); }

inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
adapt_mask_8(const __m128i b)
{ return b; }

template <typename T>
inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
band_8(__m128i a, const T b)
{ return _mm_and_si128(a, adapt_mask_8(b)); }

template <typename T>
inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
band_set_8(__m128i a, const T b)
{ a = _mm_and_si128(a, adapt_mask_8(b)); return a; }

template <typename T>
inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
bor_8(__m128i a, const T b)
{ return _mm_or_si128(a, adapt_mask_8(b)); }

template <typename T>
inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
bor_set_8(__m128i a, const T b)
{ a = _mm_or_si128(a, adapt_mask_8(b)); return a; }

inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
shl_8(__m128i a, int count)
{
    // _mm_slli_epi8 doesn't exists...
    // We shift the whole vector and clear lower bits of each byte
    a = _mm_slli_epi16(a, count);
    a &= _mm_set1_epi8(0xff << count);

    return a;
}

inline
__m128i __attribute__((__gnu_inline__, __always_inline__))
shr_8(__m128i a, int count)
{
    // _mm_srli_epi8 doesn't exists...
    // We shift the whole vector and clear higher bits of each byte
    a = _mm_srli_epi16(a, count);
    a &= _mm_set1_epi8(0xff >> count);

    return a;
}
void
pack_8_into_1_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 1, w += 8) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x01U),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x01U),  1);
        out[c + 0] |= shl_8(band_8(in[w + 2], 0x01U),  2);
        out[c + 0] |= shl_8(band_8(in[w + 3], 0x01U),  3);
        out[c + 0] |= shl_8(band_8(in[w + 4], 0x01U),  4);
        out[c + 0] |= shl_8(band_8(in[w + 5], 0x01U),  5);
        out[c + 0] |= shl_8(band_8(in[w + 6], 0x01U),  6);
        out[c + 0] |= shl_8(band_8(in[w + 7], 0x01U),  7);
    }
}

void
pack_8_into_2_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 1, w += 4) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x03U),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x03U),  2);
        out[c + 0] |= shl_8(band_8(in[w + 2], 0x03U),  4);
        out[c + 0] |= shl_8(band_8(in[w + 3], 0x03U),  6);
    }
}

void
pack_8_into_3_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 3, w += 8) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x07U),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x07U),  3);
        out[c + 0] |= shl_8(band_8(in[w + 2], 0x07U),  6);
        out[c + 1]  = bor_8(shl_8(band_8(in[w + 3], 0x07U),  1), shr_8(band_8(in[w + 2], 0x07U), 2));
        out[c + 1] |= shl_8(band_8(in[w + 4], 0x07U),  4);
        out[c + 1] |= shl_8(band_8(in[w + 5], 0x07U),  7);
        out[c + 2]  = bor_8(shl_8(band_8(in[w + 6], 0x07U),  2), shr_8(band_8(in[w + 5], 0x07U), 1));
        out[c + 2] |= shl_8(band_8(in[w + 7], 0x07U),  5);
    }
}

void
pack_8_into_4_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 1, w += 2) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x0fU),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x0fU),  4);
    }
}

void
pack_8_into_5_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 5, w += 8) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x1fU),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x1fU),  5);
        out[c + 1]  = bor_8(shl_8(band_8(in[w + 2], 0x1fU),  2), shr_8(band_8(in[w + 1], 0x1fU), 3));
        out[c + 1] |= shl_8(band_8(in[w + 3], 0x1fU),  7);
        out[c + 2]  = bor_8(shl_8(band_8(in[w + 4], 0x1fU),  4), shr_8(band_8(in[w + 3], 0x1fU), 1));
        out[c + 3]  = bor_8(shl_8(band_8(in[w + 5], 0x1fU),  1), shr_8(band_8(in[w + 4], 0x1fU), 4));
        out[c + 3] |= shl_8(band_8(in[w + 6], 0x1fU),  6);
        out[c + 4]  = bor_8(shl_8(band_8(in[w + 7], 0x1fU),  3), shr_8(band_8(in[w + 6], 0x1fU), 2));
    }
}

void
pack_8_into_6_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 3, w += 4) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x3fU),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x3fU),  6);
        out[c + 1]  = bor_8(shl_8(band_8(in[w + 2], 0x3fU),  4), shr_8(band_8(in[w + 1], 0x3fU), 2));
        out[c + 2]  = bor_8(shl_8(band_8(in[w + 3], 0x3fU),  2), shr_8(band_8(in[w + 2], 0x3fU), 4));
    }
}

void
pack_8_into_7_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t c = 0, w = 0; w < n; c += 7, w += 8) {
        out[c + 0]  = shl_8(band_8(in[w + 0], 0x7fU),  0);
        out[c + 0] |= shl_8(band_8(in[w + 1], 0x7fU),  7);
        out[c + 1]  = bor_8(shl_8(band_8(in[w + 2], 0x7fU),  6), shr_8(band_8(in[w + 1], 0x7fU), 1));
        out[c + 2]  = bor_8(shl_8(band_8(in[w + 3], 0x7fU),  5), shr_8(band_8(in[w + 2], 0x7fU), 2));
        out[c + 3]  = bor_8(shl_8(band_8(in[w + 4], 0x7fU),  4), shr_8(band_8(in[w + 3], 0x7fU), 3));
        out[c + 4]  = bor_8(shl_8(band_8(in[w + 5], 0x7fU),  3), shr_8(band_8(in[w + 4], 0x7fU), 4));
        out[c + 5]  = bor_8(shl_8(band_8(in[w + 6], 0x7fU),  2), shr_8(band_8(in[w + 5], 0x7fU), 5));
        out[c + 6]  = bor_8(shl_8(band_8(in[w + 7], 0x7fU),  1), shr_8(band_8(in[w + 6], 0x7fU), 6));
    }
}
void
unpack_1_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 8, c += 1) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x01U),  0);
        out[w + 1] = shr_8(band_8(in[c + 0], 0x02U),  1);
        out[w + 2] = shr_8(band_8(in[c + 0], 0x04U),  2);
        out[w + 3] = shr_8(band_8(in[c + 0], 0x08U),  3);
        out[w + 4] = shr_8(band_8(in[c + 0], 0x10U),  4);
        out[w + 5] = shr_8(band_8(in[c + 0], 0x20U),  5);
        out[w + 6] = shr_8(band_8(in[c + 0], 0x40U),  6);
        out[w + 7] = shr_8(band_8(in[c + 0], 0x80U),  7);
    }
}
void
unpack_2_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 4, c += 1) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x03U),  0);
        out[w + 1] = shr_8(band_8(in[c + 0], 0x0cU),  2);
        out[w + 2] = shr_8(band_8(in[c + 0], 0x30U),  4);
        out[w + 3] = shr_8(band_8(in[c + 0], 0xc0U),  6);
    }
}
void
unpack_3_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 8, c += 3) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x07U),  0);
        out[w + 1] = shr_8(band_8(in[c + 0], 0x38U),  3);
        out[w + 2] = bor_8(shr_8(band_8(in[c + 0], 0xc0U),  6), shl_8(band_8(in[c + 1], 0x01U), 2));
        out[w + 3] = shr_8(band_8(in[c + 1], 0x0eU),  1);
        out[w + 4] = shr_8(band_8(in[c + 1], 0x70U),  4);
        out[w + 5] = bor_8(shr_8(band_8(in[c + 1], 0x80U),  7), shl_8(band_8(in[c + 2], 0x03U), 1));
        out[w + 6] = shr_8(band_8(in[c + 2], 0x1cU),  2);
        out[w + 7] = shr_8(band_8(in[c + 2], 0xe0U),  5);
    }
}
void
unpack_4_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 2, c += 1) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x0fU),  0);
        out[w + 1] = shr_8(band_8(in[c + 0], 0xf0U),  4);
    }
}
void
unpack_5_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 8, c += 5) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x1fU),  0);
        out[w + 1] = bor_8(shr_8(band_8(in[c + 0], 0xe0U),  5), shl_8(band_8(in[c + 1], 0x03U), 3));
        out[w + 2] = shr_8(band_8(in[c + 1], 0x7cU),  2);
        out[w + 3] = bor_8(shr_8(band_8(in[c + 1], 0x80U),  7), shl_8(band_8(in[c + 2], 0x0fU), 1));
        out[w + 4] = bor_8(shr_8(band_8(in[c + 2], 0xf0U),  4), shl_8(band_8(in[c + 3], 0x01U), 4));
        out[w + 5] = shr_8(band_8(in[c + 3], 0x3eU),  1);
        out[w + 6] = bor_8(shr_8(band_8(in[c + 3], 0xc0U),  6), shl_8(band_8(in[c + 4], 0x07U), 2));
        out[w + 7] = shr_8(band_8(in[c + 4], 0xf8U),  3);
    }
}
void
unpack_6_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 4, c += 3) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x3fU),  0);
        out[w + 1] = bor_8(shr_8(band_8(in[c + 0], 0xc0U),  6), shl_8(band_8(in[c + 1], 0x0fU), 2));
        out[w + 2] = bor_8(shr_8(band_8(in[c + 1], 0xf0U),  4), shl_8(band_8(in[c + 2], 0x03U), 4));
        out[w + 3] = shr_8(band_8(in[c + 2], 0xfcU),  2);
    }
}
void
unpack_7_into_8_simd(
    uint8_t* __restrict__ out_ptr,
    const uint8_t* __restrict__ in_ptr,
    uint32_t n
)
{
    __m128i* out = reinterpret_cast<__m128i*>(out_ptr);
    const __m128i* in = reinterpret_cast<const __m128i*>(in_ptr);

    for (uint32_t w = 0, c = 0; w < n; w += 8, c += 7) {
        out[w + 0] = shr_8(band_8(in[c + 0], 0x7fU),  0);
        out[w + 1] = bor_8(shr_8(band_8(in[c + 0], 0x80U),  7), shl_8(band_8(in[c + 1], 0x3fU), 1));
        out[w + 2] = bor_8(shr_8(band_8(in[c + 1], 0xc0U),  6), shl_8(band_8(in[c + 2], 0x1fU), 2));
        out[w + 3] = bor_8(shr_8(band_8(in[c + 2], 0xe0U),  5), shl_8(band_8(in[c + 3], 0x0fU), 3));
        out[w + 4] = bor_8(shr_8(band_8(in[c + 3], 0xf0U),  4), shl_8(band_8(in[c + 4], 0x07U), 4));
        out[w + 5] = bor_8(shr_8(band_8(in[c + 4], 0xf8U),  3), shl_8(band_8(in[c + 5], 0x03U), 5));
        out[w + 6] = bor_8(shr_8(band_8(in[c + 5], 0xfcU),  2), shl_8(band_8(in[c + 6], 0x01U), 6));
        out[w + 7] = shr_8(band_8(in[c + 6], 0xfeU),  1);
    }
}

packer_8_ptr packer_8_simd_table[8] = {
    0,
    pack_8_into_1_simd,
    pack_8_into_2_simd,
    pack_8_into_3_simd,
    pack_8_into_4_simd,
    pack_8_into_5_simd,
    pack_8_into_6_simd,
    pack_8_into_7_simd
};

unpacker_8_ptr unpacker_8_simd_table[8] = {
    0,
    unpack_1_into_8_simd,
    unpack_2_into_8_simd,
    unpack_3_into_8_simd,
    unpack_4_into_8_simd,
    unpack_5_into_8_simd,
    unpack_6_into_8_simd,
    unpack_7_into_8_simd
};

} // namespace pack
} // namespace cxxu
